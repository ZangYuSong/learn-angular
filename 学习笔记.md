# 学习笔记

## 生命周期

### 指令和组件

* `ngOnInit` : 当 Angular 初始化完成数据绑定的输入属性后，用来初始化指令或者组件。
* `ngOnChanges` : 当 Angular 设置了一个被绑定的输入属性后触发。该回调方法会收到一个包含当前值和原值的 changes 对象。
* `ngDoCheck` : 用来检测所有变化（无论是 Angular 本身能检测还是无法检测的），并作出相应行动。在每次执行“变更检测”时被调用。
* `ngOnDestory` : 在 Angular 销毁指令或组件之前做一些清理工作，比如退订可观察对象和移除事件处理器，以免导致内存泄漏。

### 组件

* `ngAfterContentInit` : 当 Angular 把外来内容投影进自己的视图之后调用。
* `ngAfterContentChecked` : 当 Angular 检查完那些投影到自己视图中的外来内容的数据绑定之后调用。
* `ngAfterViewInit` : 在 Angular 创建完组件的视图后调用。
* `ngAfterViewChecked` : 在 Angular 检查完组件视图中的绑定后调用。

### 顺序

* `constructor` : 在任何其它生命周期钩子之前调用。可以用它来注入依赖项，但不要在这里做正事。
* `ngOnChanges` : 当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在 ngOnInit 之前。
* `ngOnInit` : 在第一轮 ngOnChanges 完成之后调用。
* `ngDoCheck` : 在每个 Angular 变更检测周期中调用。
* `ngAfterContentInit` : 当把内容投影进组件之后调用。
* `ngAfterContentChecked` : 每次完成被投影组件内容的变更检测之后调用。
* `ngAfterViewInit` : 初始化完组件及其子视图之后调用。
* `ngAfterViewChecked` : 每次做完组件视图和子视图的变更检测之后调用。
* `ngOnDestroy` : 当 Angular 每次销毁指令/组件之前调用。

## 常用装饰器

| 示例                                                                       | 说明                                                                                      |
| -------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `@Input() myProperty`                                                      | 声明一个输入属性，以便我们可以通过属性绑定更它  `<my-cmp [my-property]="someExpression">` |
| `@Output() myEvent = new EventEmitter()`                                   | 声明一个输出属性，以便我们可以通过事件绑定进行订阅 `<my-cmp (my-event)="doSomething()">`  |
| `@HostBinding('[class.valid]') isValid`                                    | 把宿主元素的属性(比如 CSS 类：valid)绑定到指令/组件的属性                                 |
| `@HostListener('click', ['$event']) onClick(e) {...}`                      | 通过指令/组件的方法(例如 onClick)订阅宿主元素的事件(例如 click)，可选传入一个参数($event) |
| `@ContentChild(myPredicate) myChildComponent : myPredicate`                | 把组件内容查询(myPredicate)的第一个结果绑定到类的 myChildComponent 属性                   |
| `@ContentChildren(myPredicate) myChildComponents : QueryList<myPredicate>` | 把组件内容查询(myPredicate)的全部结果，绑定到类的 myChildComponents 属性                  |
| `@ViewChild(myPredicate) myChildComponent : myPredicate`                   | 把组件视图查询(myPredicate)的第一个结果绑定到类的 myChildComponent 属性。对指令无效       |
| `@ViewChildren(myPredicate) myChildComponents : QueryList<myPredicate>`    | 把组件视图查询(myPredicate)的全部结果绑定到类的 myChildComponents 属性。对指令无效        |

## DOM 操作

### 简介

> Angular2 采用 AOT 静态编译模式，这种形式下需要我们的模板类型必须是稳定和安全的，直接使用 javascript 和 jquery 语言是不稳定，因为他们的编译不会提前发现错误，所以 angular2 才会选择 javascript 的超集 typescript 语言（这种语言编译期间就能发现错误）
> 为了能够支持跨平台，Angular 通过抽象层封装了不同平台的差异。比如定义了抽象类 Renderer、Renderer2 、抽象类 RootRenderer 等。此外还定义了以下引用类型：ElementRef、TemplateRef、ViewRef 、ComponentRef 和 ViewContainerRef 等。

### 推荐 Renderer2 操作 DOM，支持跨平台

``` ts
// Renderer2 : 扩展此基类以实现自定义渲染器。默认情况下，Angular 会把模板渲染成 DOM。 你可以使用自定义渲染器来拦截渲染类调用，或用于渲染一些非 DOM 的东西。
import { Directive, Input, HostListener, OnInit, Renderer2 } from '@angular/core'

@Directive({
  selector: '[appSpanHighLight]'
})
export class SpanHighLightDirective implements OnInit {
  @Input('appSpanHighLight') color: string

  constructor(private render: Renderer2) {}

  ngOnInit() {
    this.render.setStyle(this.el.nativeElement, 'color', this.color || 'green')
  }

  @HostListener('click') click() {
    alert(this.color)
  }
}
```
